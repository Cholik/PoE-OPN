protocol PoELogin with
BinaryEncodingDefaults{Endian = Endian.Big},
Visualization{AliasName = "PoE"},
Documentation
{
    ProtocolName = "Path of Exile Login Protocol",
    ShortName = "PoELogin",
    Description = ""
};

using Standard;
using PoE;
using TCP;
using Utility;
using Salsa20;
using PoEKey;

endpoint Server
	accepts KeyExchange
	accepts LoginRequest
	accepts ChangePasswordRequest
	accepts DeleteCharacterRequest
	accepts PlayRequest
	accepts CreateCharRequest
	accepts RequestLeagueInfo
	accepts UnknownPacket
	issues KeyExchange
	issues LoginRequestResult
	issues ChangePasswordResult
	issues LeagueUpdate
	issues GameServerData
	issues Unknown0
	issues LeagueInfo
	issues UnknownPacket;

client endpoint Client connected to Server;

type Handler
{
	static any message Decode(stream s, BoolWrapper unsized)
	{
		any message msg = null;
		optional GameServerData game_server_data;
		
		switch (s.CurrentByte)
		{
			case 2 =>
				msg = BinaryDecoder<LoginRequest>(s);
			case 3 =>
				msg = BinaryDecoder<LoginRequestResult>(s);
			case 4 =>
				msg = BinaryDecoder<ChangePasswordRequest>(s);
			case 5 =>
				msg = BinaryDecoder<ChangePasswordResult>(s);
			case 6 =>
				msg = BinaryDecoder<DeleteCharacterRequest>(s);
			case 7 =>
				msg = BinaryDecoder<LeagueUpdate>(s);
			case 8 =>
				msg = BinaryDecoder<PlayRequest>(s);
			case 10 =>
				msg = BinaryDecoder<CreateCharRequest>(s);
			case 11 =>
				msg = BinaryDecoder<LeagueUpdate>(s);
			case 12 =>
				game_server_data = BinaryDecoder<GameServerData>(s);
				if (game_server_data != nothing)
					game_server_data.GameServer.Declare();
				msg = game_server_data;
			case 14 =>
				msg = BinaryDecoder<Unknown0>(s);
			case 15 =>
				msg = BinaryDecoder<RequestLeagueInfo>(s);
			case 16 =>
				msg = BinaryDecoder<LeagueInfo>(s);
			default =>
				unsized.Value = true;
				msg = BinaryDecoder<UnknownPacket>(s);
		}
		
		return msg;
	}
	
	static void Dispatch(bool Input, any message msg)
	{
		if (Input)
			dispatch endpoint Server accepts msg;
		else
			dispatch endpoint Server issues msg;
	}
}

ProtocolHandler handler = new ProtocolHandler{Decode = Handler.Decode, Dispatch = Handler.Dispatch};

endpoint ReassemblyNode[any endpoint ep]
    accepts PoE.DecryptedPayload issues PoE.DecryptedPayload
{
	DecodingBuffer in_buffer = new DecodingBuffer{Input = true, Handler = handler};
	DecodingBuffer out_buffer = new DecodingBuffer{Input = false, Handler = handler};

    process this accepts s:PoE.DecryptedPayload
    {
		in_buffer.Add(s);
		dispatch endpoint GarbageEndpoint accepts s;
    }

    process this issues s:PoE.DecryptedPayload
    {
        out_buffer.Add(s);
        dispatch endpoint GarbageEndpoint issues s;
    }
}

autostart actor ReassemblyActor(ReassemblyNode server)
{    
    ~endpoint(ReassemblyNode server)
    {
		server.in_buffer.Clear();
		server.out_buffer.Clear();
    }
}

message Salsa20Info
{
	binary EncryptionKey;
	binary EncryptionIV;
	binary DecryptionIV;
}

autostart actor ServerOverTCP(TCP.Server server)
{
	array<ushort> ServerPorts = [20481];
	bool ReceivedKey = false;
	bool SentKey = false;
	binary Key = null;
	Salsa20.Context In = new Salsa20.Context{};
	Salsa20.Context Out = new Salsa20.Context{};
	
	void GetKey()
	{
		if(Key == null)
		{
			Key = PoEKey.GetKey();
			var EncryptionKey = Segment(Key as array<byte>, 0, 32) as binary;
			var EncryptionIV = Segment(Key as array<byte>, 32, 8) as binary;
			var DecryptionIV = Segment(Key as array<byte>, 48, 8) as binary;
			In.SetupKey(EncryptionKey);
			Out.SetupKey(EncryptionKey);
			In.SetupIV(EncryptionIV);
			Out.SetupIV(DecryptionIV);
		}
	}

    process server issues s:TCP.VirtualDataSegment where (s.SourcePort in ServerPorts)
    {
		if(!SentKey)
		{
			SentKey = true;
			dispatch endpoint GarbageEndpoint issues s;
			dispatch endpoint Server issues (BinaryDecoder<KeyExchange>(s.Payload) as any message);
		}
		else
		{
			GetKey();
		
			var data = Out.Process(s.Payload);
			var e = endpoint ReassemblyNode[server];
			dispatch e issues (new PoE.DecryptedPayload{Payload = data} as any message);
		}
    }
	
    process server accepts s:TCP.VirtualDataSegment where (s.DestinationPort in ServerPorts)
    {
		if(!ReceivedKey)
		{
			ReceivedKey = true;
			dispatch endpoint GarbageEndpoint accepts s;
			dispatch endpoint Server accepts (BinaryDecoder<KeyExchange>(s.Payload) as any message);
		}
		else
		{
			GetKey();
			
			var data = In.Process(s.Payload);
			var e = endpoint ReassemblyNode[server];
			dispatch e accepts (new PoE.DecryptedPayload{Payload = data} as any message);
		}
		
    }
}

type PasswordHash
{
	binary Hash with BinaryEncoding{Length = 32}; // Salted SHA-256
}

pattern StatusType = enum byte
{
	ActionSuccessful = 0x00,
	AccountDoesntExist = 0x05,
	WrongPassword = 0x06,
	NameTaken = 0x15,
	NameInvalid = 0x16
};

message KeyExchange
{
    byte Id;
	binary PublicKey with BinaryEncoding{Length = 128};
}

message LoginRequest
{
    byte Id;
	PoE.Unknown[4] u0;
	PoE.String Account;
	PasswordHash Password;
}

type Character
{
	PoE.String Name;
	PoE.String League;
	PoE.Unknown[7] u0;
	byte Level;
	PoE.Unknown[4] u1;
	PoE.Class Class;
}

type CharacterList
{
	byte CharacterCount;
	array<Character> Characters with BinaryEncoding{Length = CharacterCount};
}

type LoginCharacterList
{
	PoE.Unknown[4] u0;
	CharacterList Characters;
	PoE.Unknown[4] u1;
}

message LoginRequestResult
{
    byte Id;
	StatusType Status;
	PoE.Unknown[36] u0;
	optional [|Status == StatusType.ActionSuccessful|] LoginCharacterList Characters;
}

message ChangePasswordRequest
{
    byte Id;
	PasswordHash OldPassword;
	PasswordHash NewPassword;
}

message ChangePasswordResult
{
    byte Id;
	StatusType Status;
	PoE.Unknown[4] u0;
}

message DeleteCharacterRequest
{
    byte Id;
	PoE.String Character; 
}

message LeagueUpdate
{
    byte Id;
	StatusType Status;
	PoE.Unknown[4] u0;
	optional [|Status == StatusType.ActionSuccessful|] CharacterList Characters;
}

message PlayRequest
{
    byte Id;
	PoE.String Character; 
}

message CreateCharRequest
{
    byte Id;
	PoE.String Name;
	PoE.String League;
	PoE.Unknown[11] u0;
	PoE.Class Class;
	PoE.Unknown[32] u1;
}

message GameServerData
{
    byte Id;
	uint ConnectionId;
	PoE.Unknown[7] u0;
	PoE.GameServerInfo GameServer;
}

message Unknown0
{
    byte Id;
	byte u0;
}

message RequestLeagueInfo
{
    byte Id;
}

type League
{
	PoE.String Name;
	PoE.String Description;
	byte u0 with BinaryEncoding{Width = 6};
	byte PasswordProtected with BinaryEncoding{Width = 1};
	byte Hardcore with BinaryEncoding{Width = 1};
	PoE.Unknown[3] u1;
}

message LeagueInfo
{
    byte Id;
	uint LeagueCount;
	array<League> Leagues with BinaryEncoding{Length = LeagueCount};
}

message UnknownPacket
{
    byte Id;
}

